= 140Proof API Wrapper

This is a wrapper around the 140 Proof API.

It is split into two parts. The first is a simple interface (One40Proof::Base) and the second is a multi interface (One40Proof::Multi::Base).

<b>The simple interface requires:</b>

- http://github.com/jnunemaker/httparty

<b>The multi interface requires:</b>

- http://github.com/pauldix/typhoeus

<b>They both require:</b>

- http://flori.github.com/json

The multi interface allows you to make parallel requests (benchmarks are below). 

Documentation for the 140Proof API can be found here - http://developers.140proof.com/docs

== Install

  gem sources -a http://gemcutter.org
  sudo gem install one40_proof
  
== Benchmarks

This can be found on the benchmark dir

  n = 10
  Benchmark.bm do |x|
    x.report("Simple") do 
      n.times { One40Proof::Test.new }
    end
    x.report("Multi") do
      query = []
      n.times { query << {:method => :test} }
      One40Proof::Multi::Base.new(query)
    end
  end
  
                ## Ruby 1.9.1 ##
            user      system      total      real
  Simple  0.030000   0.020000   0.050000 (  2.507165)
  Multi   0.010000   0.010000   0.020000 (  0.426687)
  
== How To Use

<b>Making Parallel Requests</b>

Queries are created using a hash and then placed in an array

  require 'rubygems'
  require 'one40_proof/multi'

  queries = []
  
  # One40Proof's "Test" method
  queries << {:method => :test}
  
  # One40Proof's "User" method
  queries << {:method => :user, :user_id => 'sferik', :app_id => 'test'}
  
  # One40Proof's "Search" method
  queries << {:method => :search, :user_id => 'sferik', :app_id => 'test', :q => 'New York Mets'}
  
  # We then initialize the calls to the service
  a = One40Proof::Multi::Base.new(queries)
  
  # Then we have access to all our ads
  a.ads.each do |ad|
    # The Ad
    ad.image_url
    ad.byline
    ad.text
    ad.validate_impression!  # Sends a GET request to the impression_validation url
    
    
    # User
    ad.user.screen_name
    ad.user.user_id
    ad.user.profile_image_url
    ad.user.name

    # Action URLS
    ad.action_urls.click_url
    ad.action_urls.favorite_url   # Or ad.action_urls.favourite_url for the English
    ad.action_urls.impression_url
    ad.action_urls.friendship_url
    ad.action_urls.reply_url
    ad.action_urls.retweet_url
        
    # Status
    ad.status.id
  end
  
  # You can also specify what happens if a request fails
  a = One40Proof::Multi::Base.new(queries, :on_fail => "Fail!")
  
  # It can also take anything that responds to #call
  # e.g. One40Proof::Multi::Base.new(queries, :on_fail => Proc.new {raise "fail"})
  
  # If all our requests fail then:
  a.ads
    #=> ["Fail!", "Fail!", "Fail!"]
    
  # If nothing is specified on_fail then a nil object is just placed inside the array


<b>Making Single Requests</b>

Testing ad placement while in development

  require 'rubygems'
  require 'one40_proof/simple'
  
  ad = One40Proof::Test.new
  
  # The Ad
  ad.image_url
  ad.byline
  ad.text
  ad.validate_impression!  # Sends a GET request to the impression_validation url
  
  # User
  ad.user.screen_name
  ad.user.user_id
  ad.user.profile_image_url
  ad.user.name
  
  # Action URLS
  ad.action_urls.click_url
  ad.action_urls.favorite_url   # Or ad.action_urls.favourite_url for the English
  ad.action_urls.impression_url
  ad.action_urls.friendship_url
  ad.action_urls.reply_url
  ad.action_urls.retweet_url
  
  # Status
  ad.status.id
  
To get an ad for a specific user

  require 'rubygems'
  require 'one40_proof/simple'
  
  ad = One40Proof::UserAd.new(:user_id => 'reddavis', :app_id => 'your app_id')
  
  
To get an ad for a specific query

  require 'rubygems'
  require 'one40_proof/simple'
  
  ad = One40Proof::Search.new(:user_id => 'reddavis', :app_id => 'your app_id', :q => 'magic hats')

== Issues

Please report any problems or feature requests here[http://github.com/reddavis/One40Proof/issues].

== Copyright

Copyright (c) 2010 Red Davis. See LICENSE for details.